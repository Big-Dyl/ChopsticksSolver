{"version":3,"file":"static/js/440.1aa3ecb3.chunk.js","mappings":"mBAAO,MAAMA,EAITC,WAAAA,CAAYC,EAAcC,GAAa,KAHvCC,OAAS,CAAC,CAAC,EAAE,GAAG,CAAC,EAAE,IAAI,KACvBC,UAAY,IAAIC,IAAM,KACtBC,aAAc,EAAK,KAKnBC,YAAc,CAACC,EAAqBC,EAAaC,EAAaC,KAC1D,GAAGH,EAAa,CACZ,IAAII,EAAQC,KAAKC,SAAS,GACtBC,GAAaC,IACbC,EAAW,EACf,IAAI,IAAIC,EAAI,EAAGA,EAAIN,EAAMO,OAAQD,IAAI,CACjC,IAAIE,EAAO,CAAC,CAACP,KAAKV,OAAO,GAAG,GAAGU,KAAKV,OAAO,GAAG,IAAI,CAACU,KAAKV,OAAO,GAAG,GAAGU,KAAKV,OAAO,GAAG,KACpFU,KAAKQ,SAAST,EAAMM,IACpB,IAAII,EAAQT,KAAKU,YAAW,EAAMd,EAAM,EAAEC,EAAMC,GAOhD,GANAE,KAAKV,OAAS,CAAC,CAACiB,EAAK,GAAG,GAAGA,EAAK,GAAG,IAAI,CAACA,EAAK,GAAG,GAAGA,EAAK,GAAG,KACxDE,EAAQP,IACPA,EAAYO,EACZL,EAAWL,EAAMM,IAGlBP,IADHD,EAAQc,KAAKC,IAAIf,EAAOK,IAEpB,KAER,CACA,OAAOE,CACX,CAAO,CACH,IAAIL,EAAQC,KAAKC,SAAS,GACtBC,EAAYC,IACZC,EAAW,EACf,IAAI,IAAIC,EAAI,EAAGA,EAAIN,EAAMO,OAAQD,IAAI,CACjC,IAAIE,EAAO,CAAC,CAACP,KAAKV,OAAO,GAAG,GAAGU,KAAKV,OAAO,GAAG,IAAI,CAACU,KAAKV,OAAO,GAAG,GAAGU,KAAKV,OAAO,GAAG,KACpFU,KAAKQ,SAAST,EAAMM,IACpB,IAAII,EAAQT,KAAKU,YAAW,EAAKd,EAAM,EAAEC,EAAMC,GAO/C,GANAE,KAAKV,OAAS,CAAC,CAACiB,EAAK,GAAG,GAAGA,EAAK,GAAG,IAAI,CAACA,EAAK,GAAG,GAAGA,EAAK,GAAG,KACxDE,EAAQP,IACPA,EAAYO,EACZL,EAAWL,EAAMM,KAErBP,EAAOa,KAAKE,IAAIf,EAAMI,KACXL,EACP,KAER,CACA,OAAOO,CACX,GACH,KACDM,WAAa,CAACf,EAAqBC,EAAaC,EAAaC,KACzD,GAAGE,KAAKT,UAAUuB,IAAI,CAACd,KAAKV,OAAQK,IAChC,OAAOK,KAAKT,UAAUwB,IAAI,CAACf,KAAKV,OAAQK,IAE5C,GAAGC,GAAS,EACR,OAAO,EAEX,GAAGD,EAAa,CACZ,GAAwB,GAArBK,KAAKV,OAAO,GAAG,IAAgC,GAArBU,KAAKV,OAAO,GAAG,GACxC,OAAOM,EAEX,GAAwB,GAArBI,KAAKV,OAAO,GAAG,IAAgC,GAArBU,KAAKV,OAAO,GAAG,GACxC,OAAQM,EAEZ,IAAIG,EAAQC,KAAKC,SAAS,GACtBC,GAAaC,IACjB,IAAI,IAAIE,EAAI,EAAGA,EAAIN,EAAMO,OAAQD,IAAI,CACjC,IAAIE,EAAO,CAAC,CAACP,KAAKV,OAAO,GAAG,GAAGU,KAAKV,OAAO,GAAG,IAAI,CAACU,KAAKV,OAAO,GAAG,GAAGU,KAAKV,OAAO,GAAG,KACpF,IACIU,KAAKQ,SAAST,EAAMM,GACpB,CAAE,MAAMW,GACJC,QAAQC,IAAIlB,KAAKV,QACjB2B,QAAQC,IAAInB,EAAMM,IAClBY,QAAQE,MAAMH,EAClB,CACJ,IAAIP,EAAQT,KAAKU,YAAW,EAAMd,EAAM,EAAEC,EAAMC,GAMhD,GALAE,KAAKV,OAAS,CAAC,CAACiB,EAAK,GAAG,GAAGA,EAAK,GAAG,IAAI,CAACA,EAAK,GAAG,GAAGA,EAAK,GAAG,KACxDE,EAAQP,IACPA,EAAYO,GAGbX,IADHD,EAAQc,KAAKC,IAAIf,EAAOK,IAEpB,KAER,CAEA,OADAF,KAAKT,UAAU6B,IAAIC,SAAS,GAAGrB,KAAKV,OAAO,GAAG,KAAKU,KAAKV,OAAO,GAAG,KAAKU,KAAKV,OAAO,GAAG,KAAKU,KAAKV,OAAO,GAAG,KAAKK,EAAe,EAAI,IAAI,GAAIO,GACnIA,CACX,CAAO,CACH,GAAwB,GAArBF,KAAKV,OAAO,GAAG,IAAgC,GAArBU,KAAKV,OAAO,GAAG,GACxC,OAAQM,EAEZ,GAAwB,GAArBI,KAAKV,OAAO,GAAG,IAAgC,GAArBU,KAAKV,OAAO,GAAG,GACxC,OAAOM,EAEX,IAAIG,EAAQC,KAAKC,SAAS,GACtBC,EAAYC,IAChB,IAAI,IAAIE,EAAI,EAAGA,EAAIN,EAAMO,OAAQD,IAAI,CACjC,IAAIE,EAAO,CAAC,CAACP,KAAKV,OAAO,GAAG,GAAGU,KAAKV,OAAO,GAAG,IAAI,CAACU,KAAKV,OAAO,GAAG,GAAGU,KAAKV,OAAO,GAAG,KACpF,IACAU,KAAKQ,SAAST,EAAMM,GACpB,CAAE,MAAMW,GACJC,QAAQC,IAAIlB,KAAKV,QACjB2B,QAAQC,IAAInB,EAAMM,IAClBY,QAAQE,MAAMH,EAClB,CACA,IAAIP,EAAQT,KAAKU,YAAW,EAAKd,EAAM,EAAEC,EAAMC,GAM/C,GALAE,KAAKV,OAAS,CAAC,CAACiB,EAAK,GAAG,GAAGA,EAAK,GAAG,IAAI,CAACA,EAAK,GAAG,GAAGA,EAAK,GAAG,KACxDE,EAAQP,IACPA,EAAYO,IAEhBX,EAAOa,KAAKE,IAAIf,EAAMI,KACXL,EACP,KAER,CAEA,OADAG,KAAKT,UAAU6B,IAAIC,SAAS,GAAGrB,KAAKV,OAAO,GAAG,KAAKU,KAAKV,OAAO,GAAG,KAAKU,KAAKV,OAAO,GAAG,KAAKU,KAAKV,OAAO,GAAG,KAAKK,EAAe,EAAI,IAAI,GAAIO,GACnIA,CACX,GACH,KACDM,SAAYc,IACR,IAAIC,EAAK,EAAM,GAAJD,IAAW,GAAQ,EAAJA,IAAU,GAChCE,EAAK,EAAM,EAAJF,IAAU,GAAO,EAAJA,IAAU,GAC9BG,EAAa,EAAJH,EACTI,EAAQ1B,KAAKV,OAAOiC,EAAG,IAAIA,EAAG,IAC9BI,EAAQ3B,KAAKV,OAAOkC,EAAG,IAAIA,EAAG,IAClC,GAAGxB,KAAKV,OAAOiC,EAAG,KAAOvB,KAAKV,OAAOkC,EAAG,IAAI,CACxC,IAAII,EAAS,GACTC,EAAQH,EAAQC,EACpB,IAAI,IAAItB,EAAI,EAAGA,GAAKwB,EAAQxB,EAAGA,IAC1BA,GAAKM,KAAKE,IAAIa,EAAOC,IAAUE,EAAQxB,EAAI,GAC5CuB,EAAOE,KAAK,CAACD,EAAQxB,EAAGA,IAG5BL,KAAKV,OAAOiC,EAAG,IAAIA,EAAG,IAAMK,EAAOH,GAAQ,GAC3CzB,KAAKV,OAAOkC,EAAG,IAAIA,EAAG,IAAMI,EAAOH,GAAQ,EAC/C,MACOzB,KAAKP,YACJO,KAAKV,OAAOkC,EAAG,IAAIA,EAAG,IAAMG,EAAQD,GAAS,EAAIC,EAAQD,EAASC,EAAQD,EAAS,EAEnF1B,KAAKV,OAAOkC,EAAG,IAAIA,EAAG,IAAMG,EAAQD,GAAS,EAAIC,EAAQD,EAAQ,CAEzE,EACH,KACOzB,SAAY8B,IAChB,IAAIH,EAAS,GACb,IAAI,IAAIvB,EAAI,EAAGA,EAAI,EAAGA,IAClB,GAA2B,GAAxBL,KAAKV,OAAOyC,GAAM1B,GACjB,IAAI,IAAI2B,EAAI,EAAGA,EAAI,EAAGA,IACa,GAA5BhC,KAAKV,OAAc,EAAPyC,GAAUC,IACrBJ,EAAOE,KAAKT,SAAU,GAAGU,IAAO1B,IAAW,EAAP0B,IAAWC,KAAM,IAKrE,IAAIC,EAAI,EACJJ,EAAQ7B,KAAKV,OAAOyC,GAAM,GAAK/B,KAAKV,OAAOyC,GAAM,GACrD,IAAI,IAAIC,EAAI,EAAGA,GAAKH,EAAQG,EAAGA,IACxBA,GAAKrB,KAAKE,IAAIb,KAAKV,OAAOyC,GAAM,GAAI/B,KAAKV,OAAOyC,GAAM,KAAOF,EAAQG,EAAI,GACxEC,IAGR,IAAI,IAAID,EAAI,EAAGA,EAAIC,EAAGD,IAAI,CACtB,IAAIhB,EAAIK,SAAU,GAAGU,KAAQA,KAAQC,IAAK,GACtCJ,EAAOM,SAASlB,IAChBY,EAAOE,KAAKd,EAEpB,CACA,OAAOY,CAAM,EAjKb5B,KAAKV,OAAS,CAAC,CAACF,EAAE,GAAGA,EAAE,IAAI,CAACA,EAAE,GAAGA,EAAE,KACnCY,KAAKP,YAAcJ,CACvB,ECNJ8C,UAAanB,IACT,IAAIoB,EAAQ,IAAIlD,EAAO8B,EAAEqB,KAAK,GAAIrB,EAAEqB,KAAK,IACrCC,EAAWF,EAAM1C,YAAYsB,EAAEqB,KAAK,GAAGrB,EAAEqB,KAAK,IAAIlC,IAASA,KAC/DiC,EAAM5B,SAAS8B,GACfC,YAAY,CAACH,EAAM9C,OAAO,GAAG,GAAG8C,EAAM9C,OAAO,GAAG,GAAG8C,EAAM9C,OAAO,GAAG,GAAG8C,EAAM9C,OAAO,GAAG,IAAI,C","sources":["Minimax.ts","play-move-worker.ts"],"sourcesContent":["export class Solver{\r\n    status = [[1,1],[1,1]];\r\n    hashTable = new Map();\r\n    doleftovers = true;\r\n    constructor(s : number[], d : boolean){\r\n        this.status = [[s[0],s[1]],[s[2],s[3]]];\r\n        this.doleftovers = d;\r\n    }\r\n    getBestMove = (isMaximizing:boolean,depth:number,alpha:number,beta:number) => {\r\n        if(isMaximizing){\r\n            let moves = this.getMoves(0);\r\n            let bestScore = -Infinity;\r\n            let bestMove = 0;\r\n            for(let i = 0; i < moves.length; i++){\r\n                let save = [[this.status[0][0],this.status[0][1]],[this.status[1][0],this.status[1][1]]];\r\n                this.playMove(moves[i]);\r\n                let score = this.solveBoard(false,depth-1,alpha,beta);\r\n                this.status = [[save[0][0],save[0][1]],[save[1][0],save[1][1]]];\r\n                if(score > bestScore){\r\n                    bestScore = score; \r\n                    bestMove = moves[i];\r\n                }\r\n                alpha = Math.max(alpha, bestScore)\r\n                if(beta <= alpha){\r\n                    break;\r\n                }\r\n            }\r\n            return bestMove;\r\n        } else {\r\n            let moves = this.getMoves(1);\r\n            let bestScore = Infinity;\r\n            let bestMove = 0;\r\n            for(let i = 0; i < moves.length; i++){\r\n                let save = [[this.status[0][0],this.status[0][1]],[this.status[1][0],this.status[1][1]]];\r\n                this.playMove(moves[i]);\r\n                let score = this.solveBoard(true,depth-1,alpha,beta);\r\n                this.status = [[save[0][0],save[0][1]],[save[1][0],save[1][1]]];\r\n                if(score < bestScore){\r\n                    bestScore = score;\r\n                    bestMove = moves[i]; \r\n                }\r\n                beta = Math.min(beta, bestScore)\r\n                if(beta <= alpha){\r\n                    break;\r\n                }\r\n            }\r\n            return bestMove;\r\n        }\r\n    }\r\n    solveBoard = (isMaximizing:boolean,depth:number,alpha:number,beta:number) => {\r\n        if(this.hashTable.has([this.status, isMaximizing])){\r\n            return this.hashTable.get([this.status, isMaximizing]);\r\n        }\r\n        if(depth <= 0){\r\n            return 0;\r\n        }\r\n        if(isMaximizing){\r\n            if(this.status[1][0] == 0 && this.status[1][1] == 0){\r\n                return depth;\r\n            }\r\n            if(this.status[0][0] == 0 && this.status[0][1] == 0){\r\n                return -depth;\r\n            }\r\n            let moves = this.getMoves(0);\r\n            let bestScore = -Infinity;\r\n            for(let i = 0; i < moves.length; i++){\r\n                let save = [[this.status[0][0],this.status[0][1]],[this.status[1][0],this.status[1][1]]];\r\n                try{ //just some debugging stuff (leaving this here just in case)\r\n                    this.playMove(moves[i]);\r\n                    } catch(e){\r\n                        console.log(this.status);\r\n                        console.log(moves[i]);\r\n                        console.error(e)\r\n                    }\r\n                let score = this.solveBoard(false,depth-1,alpha,beta);\r\n                this.status = [[save[0][0],save[0][1]],[save[1][0],save[1][1]]];\r\n                if(score > bestScore){\r\n                    bestScore = score; \r\n                }\r\n                alpha = Math.max(alpha, bestScore)\r\n                if(beta <= alpha){\r\n                    break;\r\n                }\r\n            }\r\n            this.hashTable.set(parseInt(`${this.status[0][0]}${this.status[0][1]}${this.status[1][0]}${this.status[1][1]}${isMaximizing ? 1 : 0}`,2), bestScore);\r\n            return bestScore;\r\n        } else {\r\n            if(this.status[0][0] == 0 && this.status[0][1] == 0){\r\n                return -depth;\r\n            }\r\n            if(this.status[1][0] == 0 && this.status[1][1] == 0){\r\n                return depth;\r\n            }\r\n            let moves = this.getMoves(1);\r\n            let bestScore = Infinity;\r\n            for(let i = 0; i < moves.length; i++){\r\n                let save = [[this.status[0][0],this.status[0][1]],[this.status[1][0],this.status[1][1]]];\r\n                try{ //just some debugging stuff (leacing this here just in case)\r\n                this.playMove(moves[i]);\r\n                } catch(e){\r\n                    console.log(this.status);\r\n                    console.log(moves[i]);\r\n                    console.error(e)\r\n                }\r\n                let score = this.solveBoard(true,depth-1,alpha,beta);\r\n                this.status = [[save[0][0],save[0][1]],[save[1][0],save[1][1]]];\r\n                if(score < bestScore){\r\n                    bestScore = score; \r\n                }\r\n                beta = Math.min(beta, bestScore)\r\n                if(beta <= alpha){\r\n                    break;\r\n                }\r\n            }\r\n            this.hashTable.set(parseInt(`${this.status[0][0]}${this.status[0][1]}${this.status[1][0]}${this.status[1][1]}${isMaximizing ? 1 : 0}`,2), bestScore);\r\n            return bestScore;\r\n        }\r\n    }\r\n    playMove = (b:number) => {\r\n        let h1 = [(b & 16) >> 4, (b & 8) >> 3];\r\n        let h2 = [(b & 4) >> 2,(b & 2) >> 1];\r\n        let choice = b & 1; \r\n        let hand1 = this.status[h1[0]][h1[1]];\r\n        let hand2 = this.status[h2[0]][h2[1]];\r\n        if(this.status[h1[0]] == this.status[h2[0]]){\r\n            let output = [];\r\n            let total = hand1 + hand2;\r\n            for(let i = 0; i <= total - i; i++){\r\n              if(i != Math.min(hand1, hand2) && total - i < 5){\r\n                output.push([total - i, i]);\r\n              }\r\n            }\r\n            this.status[h1[0]][h1[1]] = output[choice][1];\r\n            this.status[h2[0]][h2[1]] = output[choice][0];\r\n        } else {\r\n            if(this.doleftovers){\r\n                this.status[h2[0]][h2[1]] = hand2 + hand1 <= 4 ? hand2 + hand1 : (hand2 + hand1) - 5;\r\n            } else {\r\n                this.status[h2[0]][h2[1]] = hand2 + hand1 <= 4 ? hand2 + hand1 : 0;\r\n            }\r\n        }\r\n    }\r\n    private getMoves = (turn:number) => {\r\n        let output = [];\r\n        for(let i = 0; i < 2; i++){\r\n            if(this.status[turn][i] != 0){\r\n                for(let j = 0; j < 2; j++){\r\n                    if(this.status[turn ^ 1][j] != 0){\r\n                        output.push(parseInt((`${turn}${i}${turn ^ 1}${j}0`),2));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        let o = 0;\r\n        let total = this.status[turn][0] + this.status[turn][1];\r\n        for(let j = 0; j <= total - j; j++){\r\n            if(j != Math.min(this.status[turn][0], this.status[turn][1]) && total - j < 5){\r\n                o++;\r\n            }\r\n        }\r\n        for(let j = 0; j < o; j++){\r\n            let e = parseInt((`${turn}0${turn}1${j}`),2)\r\n            if(!output.includes(e)){\r\n                output.push(e);\r\n            }\r\n        }\r\n        return output;\r\n    }\r\n}","import {Solver} from './Minimax';\r\nonmessage = (e) =>{\r\n    let solve = new Solver(e.data[0], e.data[3]);\r\n    let response = solve.getBestMove(e.data[1],e.data[2],-Infinity,Infinity);\r\n    solve.playMove(response);\r\n    postMessage([solve.status[0][0],solve.status[0][1],solve.status[1][0],solve.status[1][1]]);\r\n}"],"names":["Solver","constructor","s","d","status","hashTable","Map","doleftovers","getBestMove","isMaximizing","depth","alpha","beta","moves","this","getMoves","bestScore","Infinity","bestMove","i","length","save","playMove","score","solveBoard","Math","max","min","has","get","e","console","log","error","set","parseInt","b","h1","h2","choice","hand1","hand2","output","total","push","turn","j","o","includes","onmessage","solve","data","response","postMessage"],"sourceRoot":""}